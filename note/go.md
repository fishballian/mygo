
## receiver  

go方法分为value receivers和pointer receivers  
1. 两者大多时候都能自动转换，比如指针能调用value方法，数值能调用pointer方法  
2. 但是如果要修改原数据，只能使用pointer方法，因为value方法是拷贝。  
3. 对于大结构，pointer方法能减少拷贝消耗，但是使用不当可能会导致引用外泄增大内存消耗  
4. 对于立即数或者其他不可更改的数值（unaddressable value），只能调用value方法。  

## bit.OnesCount原理  

1. 先按两位一组，统计1的个数，原地存在两位中（所以可能数值为 00 01 10， 11不可能因为最多两个数）  
2. 然后将两位一组的数据加起来，变成四位一组。  
3. 重复第二步，直到只剩一组数据，就是答案。  

## defer  

每个 defer 语句都对应一个_defer 实例，多个实例使用指针连接起来形成一个单连表，保存在 goroutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。 defer 的规则总结： 延迟函数的参数是 defer 语句出现的时候就已经确定了的。 延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。 延迟函数可能操作主函数的返回值。 申请资源后立即使用 defer 关闭资源是个好习惯。  

## gc  

### 插入写屏障规则(满足强三色不变式，回收更精确，但需要rescan栈)  

插入写屏障在对象A新增一个指向对象B的指针时触发。具体规则如下：  
标记阶段：当对象A新增一个指向对象B的指针时，如果对象B是白色（未被标记），则将其标记为灰色（表示其需要被进一步扫描）。这样做可以确保在标记过程中不会遗漏任何可达对象。
目的：防止在并发标记过程中，由于新增的指针导致原本应该被回收的对象（白色对象）被错误地保留下来。  

### 删除写屏障规则(满足弱三色不变式，不精确，但避免rescan栈)  

删除写屏障在对象A删除一个指向对象B的指针时触发。具体规则如下：
标记阶段：当对象A删除一个指向对象B的指针时，如果对象B是灰色或白色，则将其重新标记为灰色（如果是白色，则直接标记为灰色；如果是灰色，则保持灰色状态）。这样做可以确保在后续扫描中，对象B仍然会被访问到，从而防止其被错误地回收。
清除阶段：在清除阶段开始时，所有在堆上的灰色对象都视为可达对象，因此不会被回收。删除写屏障确保了在并发修改指针的情况下，对象的可达性状态能够正确地被维护。

### 混合写屏障规则(满足变形的弱三色不变式)  

1. GC开始将栈上的对象全部扫描并标记为黑色（之后不再进行第二次重复扫描，无需STW）  
2. GC期间，任何在栈上创建的新对象，均为黑色。  
3. 被删除的对象标记为灰色。
4. 被添加的对象标记为灰色。

### 混合写屏障的优势  

减少STW时间：通过并发标记和写屏障机制，Go V1.8 能够显著减少垃圾回收过程中的STW时间，从而提高程序的并发性能和响应速度。
提高内存使用效率：写屏障机制有助于更准确地识别垃圾对象，减少内存碎片的产生，提高内存的使用效率。
增强并发安全性：在并发环境下，写屏障机制能够确保垃圾回收过程的安全性和正确性，防止由于并发修改导致的内存错误。  

